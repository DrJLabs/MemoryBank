---
description: USE WHEN creating new code, implementing templates, applying best practices, or following development patterns for TypeScript, Python, memory integration, and modern development approaches
globs: 
alwaysApply: false
---
---
description: "Development templates and best practices with TypeScript preference and memory integration"
globs: ["*.ts", "*.tsx", "*.py", "*.js", "*.jsx"]
alwaysApply: false
---

# Development Templates and Best Practices

## Language Preferences (from memory context)

### TypeScript (Preferred over JavaScript)
**Rationale**: Better type safety and IDE support

#### TypeScript Templates:
```typescript
// API Response Type Template
interface ApiResponse<T> {
  data: T;
  status: 'success' | 'error';
  message?: string;
  timestamp: string;
}

// Error Handling Template
class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public code?: string
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// Async Function Template with Error Handling
async function asyncOperation<T>(
  operation: () => Promise<T>
): Promise<ApiResponse<T>> {
  try {
    const data = await operation();
    return {
      data,
      status: 'success',
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    return {
      data: null as any,
      status: 'error',
      message: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString()
    };
  }
}
```

### Python (Preferred for AI Development)
**Usage**: Automation tasks, AI development, memory system integration

#### Python Templates:
```python
# Enhanced Python Script Template
#!/usr/bin/env python3
"""
Module description here
"""

import sys
import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class Config:
    """Configuration data class"""
    api_url: str = "http://localhost:8765/api/v1"
    user_id: str = "drj"
    timeout: int = 30

class ModuleName:
    """Main class template"""
    
    def __init__(self, config: Config = None):
        self.config = config or Config()
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def main_operation(self) -> Dict[str, Any]:
        """Main operation with proper error handling"""
        try:
            # Implementation here
            result = {"status": "success", "data": {}}
            self.logger.info("Operation completed successfully")
            return result
        except Exception as e:
            self.logger.error(f"Operation failed: {e}")
            return {"status": "error", "error": str(e)}

def main():
    """Enhanced main function"""
    if len(sys.argv) < 2:
        print("Usage: python script.py <command>")
        sys.exit(1)
    
    # Implementation
    
if __name__ == "__main__":
    main()
```

## Memory Integration Templates

### Memory Search Integration:
```python
# Memory-aware function template
def memory_enhanced_function(user_query: str, query_type: str = "general"):
    """Function that uses memory context for enhanced responses"""
    
    # 1. Search memories for context
    search_result = ai_memory.intelligent_memory_search(user_query, QueryType(query_type))
    
    # 2. Check confidence and use context
    if search_result.confidence > 0.5:
        context = ai_memory.get_conversational_context(user_query, query_type)
        # Use context in processing
    
    # 3. Log access for analytics
    if search_result.memories:
        ai_memory._log_memory_access(search_result.memories[:5])
    
    return result
```

### Enhanced CLI Template:
```python
# Memory-integrated CLI template
def enhanced_cli_main():
    """CLI with memory integration"""
    parser = argparse.ArgumentParser(description="Enhanced CLI with memory")
    parser.add_argument("command", help="Command to execute")
    parser.add_argument("--context", help="Search memories for context")
    parser.add_argument("--type", default="general", help="Query type for memory search")
    
    args = parser.parse_args()
    
    # Memory context if requested
    if args.context:
        context = ai_memory.get_conversational_context(args.context, args.type)
        if context:
            print("üß† Memory Context:")
            print(context)
    
    # Execute command with enhanced context
```

## Modern Development Patterns

### Error Handling (TypeScript):
```typescript
// Result pattern for error handling
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

function safeOperation<T>(operation: () => T): Result<T> {
  try {
    const data = operation();
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}
```

### API Integration (TypeScript):
```typescript
// Enhanced API client template
class ApiClient {
  constructor(private baseUrl: string, private timeout: number = 5000) {}
  
  async request<T>(
    endpoint: string, 
    options: RequestInit = {}
  ): Promise<Result<T>> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      return { success: true, data };
    } catch (error) {
      return { success: false, error: error as Error };
    }
  }
}
```

## Enhanced Command Usage (from @core-development.mdc)

### Always use enhanced commands in templates:
```bash
# Git operations
g status          # Instead of: git status
gs               # Enhanced git status
gac "message"    # Instead of: git add . && git commit -m "message"

# Navigation
mkcd new-dir     # Instead of: mkdir new-dir && cd new-dir
cdl              # Smart navigation with project detection

# Development
py script.py     # Instead of: python3 script.py
dev              # Smart server startup
health           # Environment health check

# Project context
ctx              # Show comprehensive project context
status           # Enhanced project status
```

### Environment Detection Templates:
```bash
# Enhanced script with environment detection
#!/bin/bash
source ~/.cursor-config/env

# Auto-detect project type
ctx
if [ -f "package.json" ]; then
    echo "üì¶ Node.js project detected"
    dev  # Use enhanced dev command
elif [ -f "requirements.txt" ]; then
    echo "üêç Python project detected"
    py -m venv venv && source venv/bin/activate
fi

# Use enhanced commands throughout
gs  # Check git status
```

## Quality Assurance Integration

### Code Analysis Template:
```python
# Post-development analysis
def analyze_code_quality(file_path: str):
    """Analyze code quality using Codacy integration"""
    
    # Memory search for similar patterns
    context = ai_memory.intelligent_memory_search(f"code quality {file_path}", "technical")
    
    # Run Codacy analysis
    # Use codacy_cli_analyze tool as per rules
    
    # Store results in memory for future reference
    if analysis_results:
        ai_memory.enhanced_add_memory(
            f"Code analysis results for {file_path}: {analysis_results}",
            category="TECHNICAL"
        )
```

## Project-Specific Guidelines

### Memory-C* Project Templates:
- Focus on AI memory integration patterns
- Use enterprise-grade error handling
- Implement sophisticated search and categorization
- Follow conversational memory best practices
- Leverage advanced OpenMemory API features

### General Project Templates:
- Auto-detect project structure with `ctx` (see @core-development.mdc)
- Use enhanced commands for 60-80% efficiency gain
- Implement type-safe patterns (TypeScript preferred)
- Include memory integration where beneficial
- Follow modern development practices appropriate for current date (use `date` command)

@core-development.mdc
@memory-integration.mdc
@testing-workflows.mdc
@git-workflows.mdc