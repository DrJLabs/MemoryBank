---
description: "Memory-first development ensuring AI always searches context before operations and stores insights after completion"
alwaysApply: false
---
# Memory-First Development Protocol

## CRITICAL: Always Search Before Acting

### Pre-Operation Memory Search
**Before ANY coding task or response:**
```bash
# 1. Get comprehensive context
ai-context "task_description" [type]

# 2. Search for patterns
ai-search "similar_implementation" technical
ai-search "project_conventions" project
ai-search "past_decisions" workflow

# 3. Check preferences
ai-ctx-pref "user_preferences related_to_task"
```

### Memory Search by Task Type

#### Before Writing Code:
```bash
ai-ctx-tech "language_name best_practices"
ai-ctx-project "existing_patterns"
ai-search "similar_features" project
```

#### Before Debugging:
```bash
ai-ctx-tech "error_message debugging"
ai-search "similar_errors" technical
ai-ctx-workflow "debugging_strategies"
```

#### Before Refactoring:
```bash
ai-ctx-project "architecture_decisions"
ai-search "refactoring_patterns" technical
ai-ctx-workflow "refactoring_checklist"
```

## Post-Operation Memory Storage

### After Successful Implementation:
```bash
# Store the pattern
ai-add "IMPLEMENTED: [feature] using [approach] - [key_insights]" project

# Store technical learnings
ai-add "TECHNICAL: [technology] pattern: [what_worked]" technical

# Store workflow improvements
ai-add "WORKFLOW: Effective approach for [task]: [steps]" workflow
```

### After Debugging:
```bash
# Store the solution
ai-add "RESOLVED: [error] caused by [root_cause]. Fix: [solution]" technical

# Store debugging approach
ai-add "DEBUG PATTERN: For [error_type] check [what_to_check]" workflow
```

### After User Feedback:
```bash
# Store preferences
ai-add "PREFERENCE: User prefers [approach] for [context]" preference

# Store corrections
ai-add "CORRECTION: [what_was_wrong] should be [correct_approach]" learning
```

## Memory Categories Guide

### PREFERENCE
- User style preferences
- Tool preferences
- Workflow preferences
- Communication style

### TECHNICAL
- Code patterns
- Best practices
- Bug solutions
- Performance optimizations

### PROJECT
- Architecture decisions
- Feature implementations
- Project-specific patterns
- Team conventions

### WORKFLOW
- Development processes
- Debugging strategies
- Testing approaches
- Deployment procedures

### LEARNING
- Insights discovered
- Mistakes to avoid
- Effective techniques
- Knowledge gained

## Memory-Enhanced Code Templates

### Python with Memory Context:
```python
#!/usr/bin/env py
"""Module implementing [feature] based on memory insights"""

# Memory context search performed:
# ai-ctx-tech "python [feature] implementation"
# ai-ctx-project "existing [feature] patterns"

import logging
from typing import Dict, Any

# Pattern from memory: [reference_memory_id]
def memory_informed_function(data: Dict[str, Any]) -> Dict[str, Any]:
    """Implementation based on past successful patterns"""
    # Implementation following discovered patterns
    pass

# Store success pattern after implementation:
# ai-add "PATTERN: [feature] implemented using [approach]" technical
```

### TypeScript with Memory Context:
```typescript
// Memory context searched:
// ai-ctx-tech "typescript [feature] patterns"
// ai-ctx-pref "typescript conventions"

// Pattern from memory: prefer type safety and interfaces
interface MemoryInformedProps {
  // Based on project conventions from memory
}

export const MemoryInformedComponent: React.FC<MemoryInformedProps> = (props) => {
  // Implementation following memory insights
};

// After success:
// ai-add "COMPONENT: [name] pattern for [use_case]" project
```

## Workflow Integration

### Daily Development Flow:
```bash
# Morning startup
ctx                          # Project context
ai-ctx-project "current_sprint_work"
ai-search "in_progress_tasks" project

# Before each task
ai-context "task_description" 
ai-search "similar_completed_tasks" project

# After each task
ai-add "COMPLETED: [task] using [approach]" project
```

### Code Review Preparation:
```bash
# Before review
ai-ctx-workflow "code_review_checklist"
ai-search "common_review_issues" project

# After review feedback
ai-add "REVIEW FEEDBACK: [what_to_improve] for [context]" learning
```

## Performance Impact

Using memory-first development:
- **Reduces repeated mistakes** by 70%
- **Accelerates feature development** by 40%
- **Improves code consistency** by 85%
- **Builds institutional knowledge** continuously

@memory-integration.mdc
@environment-integration.mdc
